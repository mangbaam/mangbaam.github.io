---
layout: post
title: Clean Code_8장. 경계
subtitle: 
categories: Book
tags: [book, clean_code]
---

![클린 코드 책 커버](/assets/images/CleanCodeCover.png)
#노마드코더 #북클럽 #노개북

[내용 요약(Notion)][notion]

## TIL (Today I Learned)
외부 코드를 사용할 때 우리 코드와 외부 코드 사이의 경계를 어떻게 다룰 지 학습했다.

## 오늘 읽은 범위
8장. 경계

## 책에서 기억하고 싶은 내용을 써보세요.
### 외부 코드 사용하기
---
패키지 제공자나 프레임워크 제공자는 더 많은 환경에서 돌 수 있도록 적용성을 최대한 넓히려한다.

반면, 사용자는 자신의 요구에 적합한 인터페이스를 바란다.

이로 인해 시스템 경계에서 문제가 생길 소지가 많다.

java.util.Map 의 경우 굉장히 다양한 인터페이스로 수많은 기능을 제공한다.
![Map]

Map 사용자는 누구든지 clear() 메서드를 사용해 Map 내용을 지울 권한이 있다. 또한 Map 인터페이스가 변할 경우 수정해야 할 코드가 상당히 많아진다.

다음과 같이 경계 인터페이스인 Map을 클래스 안으로 숨길 수 있다.

```java
public class Sensors {
    private Map sensors = new HashMap();

    public Sensor getById(String id) {
        return (Sensor) sensors.get(id);
    }

    // ...
}
```

이렇게 하면 Map 인터페이스가 변하더라도 나머지 프로그램에는 영향을 미치지 않는다. 또한 프로그램에 필요한 인터페이스만 제공한다.

→ 코드를 이해하기는 쉬워지고, 오용은 어려워진다.

→ 설계 규칙과 비즈니스 규칙을 따르도록 강제할 수 있다.

>Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.

### 경계 살피고 익히기
---
외부 패키지 테스트가 우리 책임은 아니지만 우리 자신을 위해 우리가 사용할 코드를 테스트하는 편이 바람직하다.

#### **학습 테스트** by 짐 뉴커크(Jim Newkirk)
> 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 것

### 학습 테스트는 공짜 이상이다
---
학습 테스트는 공짜 이상이다. 투자하는 노력보다 얻는 성과가 더 크다.

패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인한다.

새 버전이 우리 코드와 호환되지 않으면 학습 테스트가 이 사실을 곧바로 밝혀낸다.

### 아직 존재하지 않는 코드를 사용하기
---
경계의 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다.

우리가 바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제한다는 장점이 생긴다. 또한 코드 가독성도 높아지고 코드 의도도 분명해진다.

[**ADAPTER**](#어댑터-패턴) 패턴으로 API 사용을 캡슐화 해 API가 바뀔 때 수정할 코드를 한 곳으로 모을 수 있다.

### 깨끗한 경계
---
경계에서는 흥미로운 일이 많이 벌어진다. **변경**이 대표적인 예다.

- 경계에 위치하는 코드는 깔끔히 분리한다
- 기대치를 정의하는 테스트 케이스도 작성한다
- 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다
- 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자
- 새로운 클래스로 경계를 감싸거나 [ADAPTER](#어댑터-패턴) 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자

  - 어느 방법이든 코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성이 높아지며, 외부 패키지가 변했을 때 변경할 코드도 줄어든다.



## 오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요
현재 나는 서버와 협업하는 안드로이드 프로젝트를 진행하고 있다. 서버와의 통신을 통해 다양한 데이터를 주고 받으며 개발이 되어야 하는데 아직 서버 개발이 완료되지 않아 통신을 할 수 없는 상황이다.

이번 챕터에서 설명한 *경계* 너머를 알지 못하는 것이다.

나는 인터페이스를 정의하고 Mock 서버를 통해 네트워크 통신을 테스트하며 개발하고 있었는데 이 챕터를 보고 ADAPTER 패턴을 적용해봐야겠다는 생각이 들었다.

## 궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.
### 어댑터 패턴
> 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환한다.
> 
> 어댑터를 사용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 사용할 수 있다.

*출처: [위키피디아][wiki]*




[notion]: https://mangbaam.notion.site/8-8d6f1922524b40188e0af93a96404cd4
[Map]: https://s3.us-west-2.amazonaws.com/secure.notion-static.com/d9424fff-94e3-442b-b19b-4e0a763c69dc/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220304%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220304T162946Z&X-Amz-Expires=86400&X-Amz-Signature=fe256225329b3c62bd4776a445b651e2c236ede6ef5d5834f70d3d608165e61d&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject
[wiki]: https://ko.wikipedia.org/wiki/%EC%96%B4%EB%8C%91%ED%84%B0_%ED%8C%A8%ED%84%B4