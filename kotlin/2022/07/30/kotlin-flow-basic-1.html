<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>비동기 플로우에 대해서 알아보자 (1) | 맹뱀 블로그</title>
<meta name="generator" content="Jekyll v4.3.2">
<meta property="og:title" content="비동기 플로우에 대해서 알아보자 (1)">
<meta name="author" content="mangbaam">
<meta property="og:locale" content="ko">
<meta name="description" content="⭐">
<meta property="og:description" content="⭐">
<link rel="canonical" href="https://mangbaam.github.io//jekyll-theme-yat/kotlin/2022/07/30/kotlin-flow-basic-1.html">
<meta property="og:url" content="https://mangbaam.github.io//jekyll-theme-yat/kotlin/2022/07/30/kotlin-flow-basic-1.html">
<meta property="og:site_name" content="맹뱀 블로그">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-07-30T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="비동기 플로우에 대해서 알아보자 (1)">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"mangbaam"},"dateModified":"2022-07-30T00:00:00+00:00","datePublished":"2022-07-30T00:00:00+00:00","description":"⭐","headline":"비동기 플로우에 대해서 알아보자 (1)","mainEntityOfPage":{"@type":"WebPage","@id":"https://mangbaam.github.io//jekyll-theme-yat/kotlin/2022/07/30/kotlin-flow-basic-1.html"},"url":"https://mangbaam.github.io//jekyll-theme-yat/kotlin/2022/07/30/kotlin-flow-basic-1.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/jekyll-theme-yat/assets/css/main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer">
  <script src="/jekyll-theme-yat/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="https://mangbaam.github.io//jekyll-theme-yat/feed.xml" title="맹뱀 블로그">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1L746HF6Y0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1L746HF6Y0');
</script>
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/jekyll-theme-yat/">
  <img class="site-favicon" title="맹뱀 블로그" src="" onerror="this.style.display='none'">
  맹뱀 블로그
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/jekyll-theme-yat/about.html">ABOUT</a><a class="page-link" href="/jekyll-theme-yat/archives.html">ARCHIVES</a><a class="page-link" href="/jekyll-theme-yat/categories.html">CATEGORIES</a><a class="page-link" href="/jekyll-theme-yat/">HOME</a><a class="page-link" href="/jekyll-theme-yat/tags.html">TAGS</a>









<span class="page-link">



<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'ko',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">비동기 플로우에 대해서 알아보자 (1)</h1>
  <h2 class="post-subtitle">Asynchronous Flow</h2>

  <p class="post-meta">
    <time class="dt-published" datetime="2022-07-30T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jul 30, 2022
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 50 mins</span>
  </p>
<div class="post-tags">
<a class="post-tag" href="/jekyll-theme-yat/tags.html#kotlin">#kotlin</a><a class="post-tag" href="/jekyll-theme-yat/tags.html#coroutine">#coroutine</a><a class="post-tag" href="/jekyll-theme-yat/tags.html#flow">#flow</a>
</div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2>⭐</h2>

<p>중단 함수를 사용할 때는 하나의 값만 반환한다. 만약 여러 개의 값을 비동기적으로 반환하고 싶다면 우리는 Flow 를 사용할 수 있다.</p>

<h2 id="여러-값을표현하기">여러 값을 표현하기</h2>

<hr>

<p>여러 개의 값은 collections 를 사용해서 표현될 수 있다. 예를 들어 3 개의 숫자를 담고 있는 List 를 반환하는 <code class="language-plaintext highlighter-rouge">simple</code> 이라는 함수로 리스트를 받아와서 <code class="language-plaintext highlighter-rouge">forEach</code> 를 사용해 출력해 볼 수 있다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">simple</span><span class="p">():</span> <span class="nc">List</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">listOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">simple</span><span class="p">().</span><span class="nf">forEach</span> <span class="p">{</span> <span class="nf">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
2
3
</code></pre></div></div>

<h3 id="시퀀스">시퀀스</h3>

<p>각각 100ms 동안 CPU 를 사용해 계산해야 하는 경우 Sequence 를 사용해서 숫자들을 표현할 수 있다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">simpleSequence</span><span class="p">():</span> <span class="nc">Sequence</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">sequence</span> <span class="p">{</span>
    <span class="nf">repeat</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="p">-&gt;</span>
        <span class="nc">Thread</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="k">yield</span><span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">simpleSequence</span><span class="p">().</span><span class="nf">forEach</span> <span class="p">{</span> <span class="nf">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
2
3
</code></pre></div></div>

<p>이 코드는 위에서 List 를 사용한 것과 같이 3 개의 숫자를 출력하지만 각각 100 ms 만큼을 기다린다는 차이가 있다.</p>

<h3 id="중단-함수">중단 함수</h3>

<p>위의 Sequnce 를 사용했던 코드에서는 메인 스레드를 차단해버린다. 이러한 값들이 비동기적으로 계산되어야 한다면 <code class="language-plaintext highlighter-rouge">suspend</code> 키워드로 메인 스레드를 차단하지 않고 값을 리스트로 반환할 수 있다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">kotlinx.coroutines.delay</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">simpleSuspend</span><span class="p">():</span> <span class="nc">List</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="nf">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">listOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="nf">simpleSuspend</span><span class="p">().</span><span class="nf">forEach</span> <span class="p">{</span> <span class="nf">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
2
3
</code></pre></div></div>

<p>위 코드는 1초 뒤 출력된다.</p>

<h3 id="flows">Flows</h3>

<p><code class="language-plaintext highlighter-rouge">List&lt;Int&gt;</code> 를 리턴 타입으로 사용한다는 것은 모든 값을 오직 한 번만 반환하겠다는 뜻이다. 비동기 적으로 계산되는 값들을 stream 으로 표현하기 위해서는 위에서 살펴본 <code class="language-plaintext highlighter-rouge">Sequnece&lt;Int&gt;</code> 타입과 같이 <code class="language-plaintext highlighter-rouge">Flow&lt;Int&gt;</code> 타입을 사용할 수 있다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">simpleFlow</span><span class="p">():</span> <span class="nc">Flow</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">flow</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="nf">emit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span><span class="p">&lt;</span><span class="nc">Unit</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="nf">launch</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">println</span><span class="p">(</span><span class="s">"$i 를 차단하지 않았다!!"</span><span class="p">)</span>
            <span class="nf">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">simpleFlow</span><span class="p">().</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">value</span> <span class="p">-&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 를 차단하지 않았다!!
1
2 를 차단하지 않았다!!
2
3 를 차단하지 않았다!!
3
</code></pre></div></div>

<p>이 코드는 메인 스레드를 차단하지 않으면서 각 숫자를 출력할 때 100ms 를 기다렸다가 출력한다. simpleFlow() 의 Flow 가 실행되는 동안 main 함수의 “n 를 차단하지 않았다!!” 가 출력되면서 메인 함수가 차단되지 않았음을 알 수 있다</p>

<p>위 코드에서 알 수 있는 사실은</p>

<ul>
  <li>Flow 함수는 flow 를 통해서 만들어진다</li>
  <li>
<code class="language-plaintext highlighter-rouge">flow { ... }</code> 빌더 블록 내부에서는 중단될 수 있다</li>
  <li>
<code class="language-plaintext highlighter-rouge">suspend</code> 키워드 없이 가능하다</li>
  <li>
<code class="language-plaintext highlighter-rouge">emit</code> 함수를 통해 값을 방출할 수 있다</li>
  <li>
<code class="language-plaintext highlighter-rouge">collect</code> 함수를 통해 값을 수집할 수 있다</li>
</ul>

<h2 id="flow-는-cold-로-동작한다">Flow 는 Cold 로 동작한다</h2>

<hr>

<p>Flow 는 시퀀스와 비슷하게 cold 로 동작한다. cold 로 동작한다는 것은 flow 가 수집될 때까지는 flow 빌더 내부가 동작하지 않는다는 뜻이다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">kotlinx.coroutines.delay</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.Flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>

<span class="k">fun</span> <span class="nf">coldFlow</span><span class="p">():</span> <span class="nc">Flow</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">flow</span> <span class="p">{</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"Flow 시작"</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="nf">emit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"coldFlow() 함수 호출"</span><span class="p">)</span>
    <span class="kd">val</span> <span class="py">flow</span> <span class="p">=</span> <span class="nf">coldFlow</span><span class="p">()</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"수집 시작"</span><span class="p">)</span>
    <span class="n">flow</span><span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">value</span> <span class="p">-&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">}</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"다시 수집 시작"</span><span class="p">)</span>
    <span class="n">flow</span><span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">value</span> <span class="p">-&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">value</span><span class="p">)}</span>

<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>coldFlow() 함수 호출
수집 시작
Flow 시작
1
2
3
다시 수집 시작
Flow 시작
1
2
3
</code></pre></div></div>

<p>바로 이러한 점이 <code class="language-plaintext highlighter-rouge">suspend</code> 키워드를 붙이지 않아도 되는 핵심적인 이유이다. <code class="language-plaintext highlighter-rouge">coldFlow</code> 함수는 빠르게 반환되어 버리고 무엇도 기다리지 않는다.
플로우는 수집될 때마다 시작하기 때문에 우리가 <code class="language-plaintext highlighter-rouge">collect</code> 를 사용할 때마다 “Flow 시작” 이라는 문구를 볼 수 있었던 이유이다.</p>

<h2 id="flow-취소">Flow 취소</h2>

<hr>

<p>플로우는 코루틴의 일반적인 협력적 취소 매커니즘을 준수한다. 플로우 수집은 플로우가 delay 같은 취소 가능한 중단 함수에서 중단될 수 있다.
다음 예제는 플로우가 <code class="language-plaintext highlighter-rouge">withTimeoutOrNull</code> 블록을 실행할 때 어떻게 취소가 되는지 보여준다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">kotlinx.coroutines.delay</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.Flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.withTimeoutOrNull</span>

<span class="k">fun</span> <span class="nf">flowCancel</span><span class="p">():</span> <span class="nc">Flow</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">flow</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="nf">println</span><span class="p">(</span><span class="s">"Emit $i"</span><span class="p">)</span>
        <span class="nf">emit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="nf">withTimeoutOrNull</span><span class="p">(</span><span class="mi">250</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">flowCancel</span><span class="p">().</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">value</span> <span class="p">-&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"실행 완료"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Emit 1
1
Emit 2
2
실행 완료
</code></pre></div></div>

<h2 id="flow-빌더">Flow 빌더</h2>

<hr>

<p><code class="language-plaintext highlighter-rouge">flow { ... }</code> 빌더가 가장 기본적인 빌더 중 하나다. 플로우를 쉽게 만들 수 있는 다른 빌더들도 있다.</p>

<ul>
  <li>flowOf : 고정된 값들의 집합을 방출하는 flow를 만든다</li>
  <li>
<code class="language-plaintext highlighter-rouge">.asFlow()</code> : 다양한 콜렉션들과 시퀀스는 <code class="language-plaintext highlighter-rouge">.asFlow()</code> 확장 함수를 통해서 플로우 변경될 수 있다.</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.asFlow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">).</span><span class="nf">asFlow</span><span class="p">().</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">value</span> <span class="p">-&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="flow-중간-연산자">Flow 중간 연산자</h2>

<hr>

<p>플로우는 연산자로 변환될 수 있다. 중간 연산자는 업스트림 플로우에 적용되어 다운스트림 플로우를 반환한다. 이 연산자들은 여느 flow 처럼 cold 로 동작한다. 연산자로 호출하는 것은 자체적으로는 중단 함수가 아니며, 새로운 변환된 플로우를 즉시 반환한다.</p>

<p>기본 연산자는 map 이나 filter 같은 익숙한 이름도 있다. 시퀀스와의 중요한 차이점은 이 연산자 안에 있는 코드 블록에서 중단 함수를 호출할 수 있다는 점이다.</p>

<p>예를 들어, 요청된 플로우에 대해 map 연산자를 이용해 원하는 결과 값으로 매핑할 수 있으며, 요청 작업이 긴 시간을 소모하는 중단 함수인 경우에도 성공적으로 동작한다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">kotlinx.coroutines.delay</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.asFlow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.map</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">performRequest</span><span class="p">(</span><span class="n">request</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">String</span> <span class="p">{</span>
    <span class="nf">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">"return $request"</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">).</span><span class="nf">asFlow</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">request</span> <span class="p">-&gt;</span> <span class="nf">performRequest</span><span class="p">(</span><span class="n">request</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">response</span> <span class="p">-&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">response</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return 1
return 2
return 3
</code></pre></div></div>

<h3 id="변환-연산자">변환 연산자</h3>

<p>플로우 변환 연산자 중에서 가장 일반적인 것이 <code class="language-plaintext highlighter-rouge">transform</code> 이다. 이 연산자는 <code class="language-plaintext highlighter-rouge">map</code> 이나 <code class="language-plaintext highlighter-rouge">filter</code> 같은 단순한 변환이나 혹은 복잡한 다른 변환들을 구현하기 위해 사용된다. <code class="language-plaintext highlighter-rouge">transform</code> 연산자를 사용해서 우리는 임의의 시간에 임의의 값을 방출할 수 있다.</p>

<p>예를 들어, <code class="language-plaintext highlighter-rouge">tranform</code> 을 사용해 오래 걸리는 비동기 요청을 수행하기 전에 기본 문자열을 방출하고 응답이 도착하면 그 결과를 방출할 수 있다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">kotlinx.coroutines.delay</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.asFlow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.transform</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">performRequest</span><span class="p">(</span><span class="n">request</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">String</span> <span class="p">{</span>
    <span class="nf">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">"return $request"</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">).</span><span class="nf">asFlow</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">transform</span> <span class="p">{</span> <span class="n">request</span> <span class="p">-&gt;</span>
            <span class="nf">emit</span><span class="p">(</span><span class="s">"$request 요청 보내기"</span><span class="p">)</span>
            <span class="nf">emit</span><span class="p">(</span><span class="nf">performRequest</span><span class="p">(</span><span class="n">request</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">response</span> <span class="p">-&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">response</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 요청 보내기
return 1
2 요청 보내기
return 2
3 요청 보내기
return 3
</code></pre></div></div>

<h3 id="크기-제한-연산자">크기 제한 연산자</h3>

<p><code class="language-plaintext highlighter-rouge">take</code> 같은 크기 제한 중간 연산자는 정의된 임계치에 도달하면 실행을 취소한다. 코루틴 취소는 예외를 발생시키는 방식으로 수행되며, 그렇기 때문에 <code class="language-plaintext highlighter-rouge">try ~ finally</code> 같은 자원 관리형 함수들이 정상적으로 동작할 수 있게 한다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.Flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.take</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>

<span class="k">fun</span> <span class="nf">numbers</span><span class="p">():</span> <span class="nc">Flow</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">flow</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="nf">emit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="nf">emit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="nf">println</span><span class="p">(</span><span class="s">"여기 부터는 실행되지 않을 겁니다"</span><span class="p">)</span>
        <span class="nf">emit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
        <span class="nf">println</span><span class="p">(</span><span class="s">"finally 에서 실행 됨"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="nf">numbers</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">take</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">value</span> <span class="p">-&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
2
finally 에서 실행 됨
</code></pre></div></div>

<p>두 번째 수를 방출하고 멈춘 것을 볼 수 있다.</p>

<h2 id="flow-종단terminal-연산자">Flow 종단(terminal) 연산자</h2>

<hr>

<p>플로우 종단 연산자는 플로우 수집을 시작하는 중단 함수이다. <code class="language-plaintext highlighter-rouge">collect</code> 연산자가 가장 대표적이고, 다음과 같은 다른 종단 연산자들도 있다.</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">toList</code> 나 <code class="language-plaintext highlighter-rouge">toSet</code> 같은 다양한 컬렉션으로의 변환</li>
  <li>
<code class="language-plaintext highlighter-rouge">first</code> 로 첫 번째 값만 방출하거나 <code class="language-plaintext highlighter-rouge">single</code> 로 단일 값만 방출함을 보장</li>
  <li>플로우를 <code class="language-plaintext highlighter-rouge">reduce</code> 나 <code class="language-plaintext highlighter-rouge">fold</code> 를 이용하여 값으로 변환</li>
</ul>

<p>예를 들어</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="nn">flow</span>

<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.asFlow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.map</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.reduce</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">sum</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">).</span><span class="nf">asFlow</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">it</span> <span class="p">*</span> <span class="n">it</span> <span class="p">}</span>
        <span class="p">.</span><span class="nf">reduce</span> <span class="p">{</span> <span class="n">accumulator</span><span class="p">,</span> <span class="n">value</span> <span class="p">-&gt;</span> <span class="n">accumulator</span> <span class="p">+</span> <span class="n">value</span> <span class="p">}</span>

    <span class="nf">println</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 코드는 <strong>55</strong> 를 반환한다.</p>

<h2 id="플로우는-순차적이다">플로우는 순차적이다</h2>

<hr>

<p>플로우의 독립된 각 컬렉션들은 다중 플로우가 사용되는 특별한 연산자가 사용되지 않은 이상 순차적으로 수행된다. 수집은 종단 연산자를 호출한 코루틴에서 직접 수행되며 기본적으로 새로운 코루틴을 생성하지는 않는다. 각각 방출된 값은 업스트림의 모든 중간 연산자들에 의해 처리되어 다운스트림으로 전달되며 마지막으로 종단 연산자로 전달된다.</p>

<p>다음은 짝수 만을 필터링해서 문자열로 변환하는 예제이다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.asFlow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.filter</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.map</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">).</span><span class="nf">asFlow</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">filter</span> <span class="p">{</span>
            <span class="nf">println</span><span class="p">(</span><span class="s">"Filter $it"</span><span class="p">)</span>
            <span class="n">it</span> <span class="p">%</span> <span class="mi">2</span> <span class="p">==</span> <span class="mi">0</span>
        <span class="p">}.</span><span class="nf">map</span> <span class="p">{</span>
            <span class="nf">println</span><span class="p">(</span><span class="s">"Map $it"</span><span class="p">)</span>
            <span class="s">"문자열 $it"</span>
        <span class="p">}.</span><span class="nf">collect</span> <span class="p">{</span>
            <span class="nf">println</span><span class="p">(</span><span class="s">"Collect $it"</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Filter 1
Filter 2
Map 2
Collect 문자열 2
Filter 3
Filter 4
Map 4
Collect 문자열 4
Filter 5
</code></pre></div></div>

<h2 id="flow-컨텍스트">Flow 컨텍스트</h2>

<hr>

<p>플로우 수집은 항상 호출한 코루틴의 컨텍스트 안에서 수행된다. 이러한 특성을 Context preservation (컨텍스트 보존) 이라고 한다.</p>

<p>컨텍스트가 보존되기 때문에 호출자를 블록하지 않고 실행 컨텍스트에 관계 없이 비동기 작업을 할 수 있는 것이다.</p>

<h3 id="withcontext-사용-주의">withContext 사용 주의</h3>

<p>보통 <code class="language-plaintext highlighter-rouge">withContext</code> 는 코루틴의 컨텍스트를 전환하기 위해 사용되는데 <code class="language-plaintext highlighter-rouge">flow { ... }</code> 빌더 내부의 코드는 컨텍스트 보존 특성을 지켜야하기 때문에 다른 컨텍스트에서 값을 방출하는 것이 허용되지 않는다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">kotlinx.coroutines.Dispatchers</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.Flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.withContext</span>

<span class="k">fun</span> <span class="nf">wrong</span><span class="p">():</span> <span class="nc">Flow</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">flow</span> <span class="p">{</span>
    <span class="nf">withContext</span><span class="p">(</span><span class="nc">Dispatchers</span><span class="p">.</span><span class="nc">Default</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
            <span class="nc">Thread</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
            <span class="nf">emit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="nf">wrong</span><span class="p">().</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">value</span> <span class="p">-&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exception in thread "main" java.lang.IllegalStateException: Flow invariant is violated:
		Flow was collected in [CoroutineId(1), "coroutine#1":BlockingCoroutine{Active}@14d02ae6, BlockingEventLoop@5bd0e297],
		but emission happened in [CoroutineId(1), "coroutine#1":DispatchedCoroutine{Active}@7f824d68, Dispatchers.Default].
		Please refer to 'flow' documentation or use 'flowOn' instead
 at kotlinx.coroutines.flow.internal.SafeCollector_commonKt.checkContext (SafeCollector.common.kt:85) 
 at kotlinx.coroutines.flow.internal.SafeCollector.checkContext (SafeCollector.kt:106) 
 at kotlinx.coroutines.flow.internal.SafeCollector.emit (SafeCollector.kt:83) 
</code></pre></div></div>

<p>위 에러 메시지를 잘 보면 <code class="language-plaintext highlighter-rouge">flowOn</code> 을 사용해보라고 알려주고 있다.</p>

<h3 id="flowon-연산자">flowOn 연산자</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">package</span> <span class="nn">flow</span>

<span class="k">import</span> <span class="nn">kotlinx.coroutines.Dispatchers</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.Flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.flowOn</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>

<span class="k">fun</span> <span class="nf">log</span><span class="p">(</span><span class="n">msg</span><span class="p">:</span> <span class="nc">String</span><span class="p">)</span> <span class="p">=</span> <span class="nf">println</span><span class="p">(</span><span class="s">"[${Thread.currentThread().name}] $msg"</span><span class="p">)</span>

<span class="k">fun</span> <span class="nf">flowOnTest</span><span class="p">():</span> <span class="nc">Flow</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">flow</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="nc">Thread</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="nf">log</span><span class="p">(</span><span class="s">"Emitting $i"</span><span class="p">)</span>
        <span class="nf">emit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}.</span><span class="nf">flowOn</span><span class="p">(</span><span class="nc">Dispatchers</span><span class="p">.</span><span class="nc">Default</span><span class="p">)</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span> 
    <span class="nf">flowOnTest</span><span class="p">().</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">value</span> <span class="p">-&gt;</span>
        <span class="nf">log</span><span class="p">(</span><span class="s">"Collected $value"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[DefaultDispatcher-worker-1 @coroutine#2] Emitting 1
[main @coroutine#1] Collected 1
[DefaultDispatcher-worker-1 @coroutine#2] Emitting 2
[main @coroutine#1] Collected 2
[DefaultDispatcher-worker-1 @coroutine#2] Emitting 3
[main @coroutine#1] Collected 3
</code></pre></div></div>

<p>위에서 <code class="language-plaintext highlighter-rouge">withContext</code> 를 사용한 예제와 비슷한 로직이지만 <code class="language-plaintext highlighter-rouge">flowOn</code> 을 사용했을 때는 컨텍스트가 원하는대로 변전되어 사용할 수 있는 것을 확인할 수 있다.</p>

<p>그리고 하나 더 확인해야 할 부분은 코드를 실행하고 있는 코루틴이다. collect 를 하고 있는 main 은 coroutine#1 에서 실행되고 있지만 emit 하고 있는 flowOnTest 는 새로운 코루틴인 coroutine#2 가 생성되어 실행되고 있다.</p>

<p>이는 플로우의 기본적인 특성인 순차성을 일부 포기했다고 볼 수도 있다.</p>

<h2 id="버퍼링">버퍼링</h2>

<hr>

<p>플로우 로직을 여러 코루틴에서 수행하는 것은 플로우 수집 시간 관저에서는 도움이 될 수 있다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="nn">flow</span>

<span class="k">import</span> <span class="nn">kotlinx.coroutines.delay</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.Flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.buffer</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>
<span class="k">import</span> <span class="nn">kotlin.system.measureTimeMillis</span>

<span class="k">fun</span> <span class="nf">longJob</span><span class="p">():</span> <span class="nc">Flow</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">flow</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="nf">emit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">withNoBuffer</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">time</span> <span class="p">=</span> <span class="nf">measureTimeMillis</span> <span class="p">{</span>
        <span class="nf">longJob</span><span class="p">()</span>
            <span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">value</span> <span class="p">-&gt;</span>
                <span class="nf">delay</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span>
                <span class="nf">println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"$time ms 에 수집 됨"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">withBuffer</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">time</span> <span class="p">=</span> <span class="nf">measureTimeMillis</span> <span class="p">{</span>
        <span class="nf">longJob</span><span class="p">()</span>
            <span class="p">.</span><span class="nf">buffer</span><span class="p">()</span>
            <span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">value</span> <span class="p">-&gt;</span>
                <span class="nf">delay</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span>
                <span class="nf">println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"$time ms 에 수집 됨"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"버퍼 없이 실행"</span><span class="p">)</span>
    <span class="nf">withNoBuffer</span><span class="p">()</span>
    
    <span class="nf">println</span><span class="p">(</span><span class="s">"\n버퍼 추가 후 실행"</span><span class="p">)</span>
    <span class="nf">withBuffer</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 코드를 실행 시켰을 때 결과는 다음과 같다</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>버퍼 없이 실행
1
2
3
1218 ms 에 수집 됨

버퍼 추가 후 실행
1
2
3
1037 ms 에 수집 됨
</code></pre></div></div>

<p>같은 로직에 buffer 를 추가하지 않았던 코드에서는 약 1200 ms 가 소요된 반면 buffer 를 추가한 코드에서는 약 1000 ms 가 소요되었다.</p>

<p>buffer 를 추가하면 새로운 코루틴을 만들어서 처리를 하고, 각 결과는 channel 을 통해 주고 받으며 최종적으로 시간을 줄여줄 수 있는 것이다.</p>

<p>위 코드에서는 첫 번째 수를 처리하기 위해 100ms 를 기다리고, 각각의 수를 처리하기 위해 300ms 씩 기다리면서 1000ms 만을 소요하게 되었다.</p>

<p>위에서 flowOn 에 대해서 설명했는데 flowOn 에서도 마찬가지로 새로운 코루틴이 만들어진다고 했는데, 컨텍스트가 전환 되는지 여부만 다를 뿐 flowOn 에서도 동일한 버퍼링 매커니즘을 사용한다.</p>

<h3 id="conflate">conflate</h3>

<p>어떤 플로우가 방출하는 속도보다 그 플로우를 소모(수집)해서 처리하는 시간이 더 오래걸리는 경우 플로우가 방출하는 중간 내용들을 전부 처리하지 않고 최종 결과만을 취하고 싶을 때 <code class="language-plaintext highlighter-rouge">conflate</code> 연산자를 사용하면 된다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="nn">flow</span>

<span class="k">import</span> <span class="nn">kotlinx.coroutines.delay</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.Flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.conflate</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>
<span class="k">import</span> <span class="nn">kotlin.system.measureTimeMillis</span>

<span class="k">fun</span> <span class="nf">conflate</span><span class="p">():</span> <span class="nc">Flow</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">flow</span> <span class="p">{</span> 
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="nf">emit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span> 
    <span class="kd">val</span> <span class="py">time</span> <span class="p">=</span> <span class="nf">measureTimeMillis</span> <span class="p">{</span> 
        <span class="nf">conflate</span><span class="p">()</span>
            <span class="p">.</span><span class="nf">conflate</span><span class="p">()</span>
            <span class="p">.</span><span class="nf">collect</span> <span class="p">{</span>  <span class="n">value</span> <span class="p">-&gt;</span>
                <span class="nf">delay</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span>
                <span class="nf">println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"수행 시간: $time"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
3
수행 시간: 767
</code></pre></div></div>

<p>위 예제에서 첫 번째 값(1)을 처리하는 동안 2, 3 이 방출되는데, 이때 <code class="language-plaintext highlighter-rouge">conflate</code> 를 사용하여 처리하고 있던 첫 번째 값을 처리한 후 방출된 값 중 가장 최신 값인 3을 처리하면서 1을 방출할 때까지 걸린 시간 100ms + 1과 3을 수집하여 처리하는 데까지 걸린 시간 300 x 2 = 약 700 ms 만큼의 시간이 소요된 것이다.</p>

<h3 id="최신-값-처리">최신 값 처리</h3>

<p>바로 위에서 살펴본 conflate 는 방출과 수집이 모두 느릴 경우 중간 값들을 삭제함으로서 수행하는데 그 대안으로는 <code class="language-plaintext highlighter-rouge">xxxLatest</code> 연산자가 있다.</p>

<p><code class="language-plaintext highlighter-rouge">xxxLastest</code> 연산자는 새로운 값이 방출될 때마다 느린 수집기를 취소하고 다시 시작하도록 동작한다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">kotlinx.coroutines.delay</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.Flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.collectLatest</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.flow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>
<span class="k">import</span> <span class="nn">kotlin.system.measureTimeMillis</span>

<span class="k">fun</span> <span class="nf">latest</span><span class="p">():</span> <span class="nc">Flow</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">flow</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="nf">emit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">time</span> <span class="p">=</span> <span class="nf">measureTimeMillis</span> <span class="p">{</span>
        <span class="nf">latest</span><span class="p">()</span>
            <span class="p">.</span><span class="nf">collectLatest</span> <span class="p">{</span>  <span class="n">value</span> <span class="p">-&gt;</span>
                <span class="nf">println</span><span class="p">(</span><span class="s">"Collecting $value"</span><span class="p">)</span>
                <span class="nf">delay</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span>
                <span class="nf">println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"수행 시간: $time"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Collecting 1
Collecting 2
Collecting 3
3
수행 시간: 688
</code></pre></div></div>

<p>위 예제를 보면 Collecting n 은 값을 수집할 때마다 출력했지만 수집한 값을 처리하는데 300 ms 가 소요되면서 앞선 값들은 모두 취소되고 마지막 값인 3 만 끝까지 처리되어 출력되는 것을 알 수 있다.</p>

<h2 id="다중-플로우-합성">다중 플로우 합성</h2>

<hr>

<h3 id="zip">Zip</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.asFlow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.flowOf</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.zip</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">nums</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">).</span><span class="nf">asFlow</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">strs</span> <span class="p">=</span> <span class="nf">flowOf</span><span class="p">(</span><span class="s">"하나"</span><span class="p">,</span> <span class="s">"둘"</span><span class="p">,</span> <span class="s">"셋"</span><span class="p">)</span>

    <span class="n">nums</span><span class="p">.</span><span class="nf">zip</span><span class="p">(</span><span class="n">strs</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="p">-&gt;</span> <span class="s">"$i -&gt; $s"</span><span class="p">}</span>
        <span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="nf">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 -&gt; 하나
2 -&gt; 둘
3 -&gt; 셋
</code></pre></div></div>

<h3 id="combine">Combine</h3>

<p>플로우가 어떤 변수나 연산의 가장 최신의 값을 표현할 때 해당 플로우의 가장 최근 값에 계산을 하고, 업스트림 플로우 증 하나가 새로운 값을 방출하면 다시 계산해야 할 수 있다. 이와 관련된 연산자들을 <code class="language-plaintext highlighter-rouge">combine</code> 이라고 부른다.</p>

<p>예를 들어 위 예제(zip)에서 숫자가 300ms 마다 업데이트되고, 문자열이 400ms 마다 업데이트 되면 zip 으로 압축했을 때 더 긴 연산인 400ms 마다 출력된다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">kotlinx.coroutines.delay</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.asFlow</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.flowOf</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.onEach</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.zip</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">nums</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">).</span><span class="nf">asFlow</span><span class="p">().</span><span class="nf">onEach</span> <span class="p">{</span> <span class="nf">delay</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span> <span class="p">}</span>
    <span class="kd">val</span> <span class="py">strs</span> <span class="p">=</span> <span class="nf">flowOf</span><span class="p">(</span><span class="s">"하나"</span><span class="p">,</span> <span class="s">"둘"</span><span class="p">,</span> <span class="s">"셋"</span><span class="p">).</span><span class="nf">onEach</span> <span class="p">{</span> <span class="nf">delay</span><span class="p">(</span><span class="mi">400</span><span class="p">)</span> <span class="p">}</span>
    <span class="kd">val</span> <span class="py">startTime</span> <span class="p">=</span> <span class="nc">System</span><span class="p">.</span><span class="nf">currentTimeMillis</span><span class="p">()</span>
    <span class="n">nums</span><span class="p">.</span><span class="nf">zip</span><span class="p">(</span><span class="n">strs</span><span class="p">)</span> <span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">-&gt;</span> <span class="s">"$a -&gt; $b"</span> <span class="p">}</span>
        <span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">value</span> <span class="p">-&gt;</span>
            <span class="nf">println</span><span class="p">(</span><span class="s">"$value 수행 시간 : ${System.currentTimeMillis() - startTime} ms"</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 -&gt; 하나 수행 시간 : 435 ms
2 -&gt; 둘 수행 시간 : 835 ms
3 -&gt; 셋 수행 시간 : 1237 ms
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">zip</code> 대신 <code class="language-plaintext highlighter-rouge">combine</code> 연산자를 사용한 예제는 다음과 같다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">kotlinx.coroutines.delay</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.flow.*</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.runBlocking</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">nums</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">).</span><span class="nf">asFlow</span><span class="p">().</span><span class="nf">onEach</span> <span class="p">{</span> <span class="nf">delay</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span> <span class="p">}</span>
    <span class="kd">val</span> <span class="py">strs</span> <span class="p">=</span> <span class="nf">flowOf</span><span class="p">(</span><span class="s">"하나"</span><span class="p">,</span> <span class="s">"둘"</span><span class="p">,</span> <span class="s">"셋"</span><span class="p">).</span><span class="nf">onEach</span> <span class="p">{</span> <span class="nf">delay</span><span class="p">(</span><span class="mi">400</span><span class="p">)</span> <span class="p">}</span>
    <span class="kd">val</span> <span class="py">startTime</span> <span class="p">=</span> <span class="nc">System</span><span class="p">.</span><span class="nf">currentTimeMillis</span><span class="p">()</span>
    <span class="n">nums</span><span class="p">.</span><span class="nf">combine</span><span class="p">(</span><span class="n">strs</span><span class="p">)</span> <span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">-&gt;</span> <span class="s">"$a -&gt; $b"</span> <span class="p">}</span>
        <span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="n">value</span> <span class="p">-&gt;</span>
            <span class="nf">println</span><span class="p">(</span><span class="s">"$value 수행 시간 : ${System.currentTimeMillis() - startTime} ms"</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 -&gt; 하나 수행 시간 : 439 ms
2 -&gt; 하나 수행 시간 : 641 ms
2 -&gt; 둘 수행 시간 : 841 ms
3 -&gt; 둘 수행 시간 : 942 ms
3 -&gt; 셋 수행 시간 : 1242 ms
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">zip</code> 과는 다르게 출력되었는데, 결과를 보면 <code class="language-plaintext highlighter-rouge">nums</code> 나 <code class="language-plaintext highlighter-rouge">strs</code> 가 각각 방출하고 마지막에 병합된 결과가 출력된 것을 볼 수 있다.</p>

<p>(<a href="https://mangbaam.github.io/kotlin/2022/07/30/kotlin-flow-basic-2.html">다음 게시글</a>에서 계속…)</p>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/jekyll-theme-yat/git/2022/07/25/git-merge-rebase.html" title="Git merge와 rebase. 언제 어떻게 사용해야 할까">Git merge와 rebase. 언제 어떻게 사용해야...</a><a class="next" href="/jekyll-theme-yat/kotlin/2022/07/30/kotlin-flow-basic-2.html" title="비동기 플로우에 대해서 알아보자 (2)">비동기 플로우에 대해서 알아보자 (2)</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li><a class="post-link" href="/jekyll-theme-yat/android/2022/08/31/android-xml-view-manager.html" title="비동기 플로우에 대해서 알아보자 (2)">Android TextView 를 중첩(계층)할 수 없는 이유</a></li>
<li><a class="post-link" href="/jekyll-theme-yat/kotlin/2022/07/03/coroutine-basic.html" title="비동기 플로우에 대해서 알아보자 (2)">Kotlin Coroutine Basic</a></li>
<li><a class="post-link" href="/jekyll-theme-yat/book/2022/03/01/clean-code-5.html" title="비동기 플로우에 대해서 알아보자 (2)">Clean Code_5장. 형식 맞추기</a></li>
<li><a class="post-link" href="/jekyll-theme-yat/project/2022/05/10/project-suwiki-networking.html" title="비동기 플로우에 대해서 알아보자 (2)">[SUWIKI] Networking</a></li>
</ul>
    </div>
<div class="post-comments">  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'https://mangbaam.github.io//jekyll-theme-yat/kotlin/2022/07/30/kotlin-flow-basic-1.html';
      this.page.identifier = 'https://mangbaam.github.io//jekyll-theme-yat/kotlin/2022/07/30/kotlin-flow-basic-1.html';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://https-mangbaam-github-io.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
</div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/jekyll-theme-yat/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Copyright Mangbaam © 2022-2023 mangbaam</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/jekyll-theme-yat/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
